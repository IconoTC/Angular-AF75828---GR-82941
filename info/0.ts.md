---
title: TYPESCRIPT EN ANGULAR = Introducci√≥n a TypeScript
module: 1
---

- [üß© Tipos (Avanzados) en TypeScript para Angular](#-tipos-avanzados-en-typescript-para-angular)
  - [üéØ Objetivos del m√≥dulo](#-objetivos-del-m√≥dulo)
  - [üß† Inferencia y anotaci√≥n de tipos](#-inferencia-y-anotaci√≥n-de-tipos)
    - [Inferencia de tipos](#inferencia-de-tipos)
    - [Tipos literales](#tipos-literales)
    - [El tipo any](#el-tipo-any)
    - [Variables y tipos expl√≠citos (type annotations)](#variables-y-tipos-expl√≠citos-type-annotations)
    - [üìò Uso de tipos inferidos y expl√≠citos en funciones](#-uso-de-tipos-inferidos-y-expl√≠citos-en-funciones)
      - [‚öôÔ∏è Tipado del retorno de las funciones obligatorio](#Ô∏è-tipado-del-retorno-de-las-funciones-obligatorio)
  - [üß† Tipos propios (custom Types)](#-tipos-propios-custom-types)
    - [Alias de tipos (type aliases)](#alias-de-tipos-type-aliases)
    - [Interfaces](#interfaces)
      - [Interfaces y clases](#interfaces-y-clases)
    - [Tipos v. interfaces](#tipos-v-interfaces)
      - [Extensi√≥n de interfaces y combinaci√≥n de tipos](#extensi√≥n-de-interfaces-y-combinaci√≥n-de-tipos)
      - [Uso de tipos o interfaces](#uso-de-tipos-o-interfaces)
  - [Tipado de los datos](#tipado-de-los-datos)
    - [DTO (Data Transfer Object) y utilidades de tipos](#dto-data-transfer-object-y-utilidades-de-tipos)
  - [üß† Clases en ES6 y typeScript](#-clases-en-es6-y-typescript)
    - [Definici√≥n de clases en ES6+](#definici√≥n-de-clases-en-es6)
    - [Clases en TypeScript](#clases-en-typescript)
      - [Modificadores de acceso](#modificadores-de-acceso)
      - [Propiedades de par√°metros](#propiedades-de-par√°metros)
    - [Herencia de clases](#herencia-de-clases)
      - [Sobre-escritura (overriding) de m√©todos](#sobre-escritura-overriding-de-m√©todos)
      - [Clases abstractas](#clases-abstractas)

## üß© Tipos (Avanzados) en TypeScript para Angular

### üéØ Objetivos del m√≥dulo

- Comprender el concepto de inferencia v. anotaci√≥n de tipos
- Usar tipos inferidos y expl√≠citos para funciones
- Crear tipos propios (custom types) mediante alias de tipos e interfaces.

### üß† Inferencia y anotaci√≥n de tipos

#### Inferencia de tipos

Los resultados inmediatos del uso de TypeScript son la **inferencia de tipos** y el **chequeo de tipos** (type checking) que se realiza en el editor de c√≥digo, incluso antes de compilar el c√≥digo.

Respecto a lo primero, TypeScript puede **inferir el tipo** de una **variable** bas√°ndose en el valor asignado.

```ts sample0.basic.ts
let x = 10; // x: number
```

Sin necesidad de especificar el tipo de la variable `x`, TypeScript es capaz de inferir que `x` es de tipo `number`.
Adem√°s, en el propio editor de c√≥digo, TypeScript mostrar√° un error si se intenta asignar un valor de tipo distinto al inferido.

```ts sample0.basic.ts
let x = 10;
x = 'Hola'; // Error: Type 'string' is not assignable to type 'number'
```

Para los valores primitivos, los tipos inferidos son los mismos siete tipos primitivos de JavaScript: `number`, `string`, `boolean`, `null`, `undefined`, `symbol` y `bigint`.

Para los objetos, TypeScript infiere el tipo de la variable a partir de la estructura del objeto.

```ts sample0.basic.ts
let user = {
  name: 'John',
  age: 30,
};
// user: { name: string; age: number }
```

Es importante aprovechar la inferencia de tipos y no usar anotaciones innecesarias. Aunque depende del conjunto de reglas activo, es habitual que el linter nos alerte en caso de usar anotaciones innecesarias.

```ts sample0.basic.ts
let state: boolean = false;

// Type boolean trivially inferred from a boolean literal, remove type annotation.
// eslint@typescript-eslint/no-inferrable-types
// let state = false
```

#### Tipos literales

Hay que considerar la diferencia entre las declaraciones `let` y `const`, dando esta segunda lugar a los **tipos literales** (literal types). Esto se debe a que TypeScript trata de hacer siempre la inferencia lo m√°s espec√≠fica posible.

```ts sample0.basic.ts
let x = 10; // x: number
const y = 20; // y: 20
```

En caso de `let` es posible forzar un tipo literal una conversi√≥n de tipo (type casting), de las que luego hablaremos. Por ejemplo, si se quiere que `x` sea un n√∫mero 10, se puede hacer lo siguiente:

```ts sample0.basic.ts
let x = 10 as const; // x: 10
```

#### El tipo any

El tipo `any` **impl√≠cito** aparece cuando TypeScript no puede inferir el tipo de una variable. Es un tipo que **no** proporciona **ninguna** informaci√≥n sobre el valor de la variable.

```ts sample0.basic.ts
let x; // x: any
x = 10; // x: any
x = 'Hola'; // x: any
```

#### Variables y tipos expl√≠citos (type annotations)

En caso de un any impl√≠citos, entre otros, es conveniente usar **anotaciones de tipos** (type annotations), para proporcionar (anotar) tipos **expl√≠citos** a las variables.

```ts sample0.basic.ts
let x;
x = 10; // x: any;
let y: number; // anotaci√≥n de tipo
y = 12; // y: number
```

Las anotaciones son especialmente importantes, en el caso de los **par√°metros** y **valores de retorno** de las **funciones**.

```ts sample0.basic.ts
function greet(name: string): string {
  return `Hello, ${name}!`;
}

greet('John'); // Correcto
greet(42); // Error: Argument of type 'number' is not assignable to parameter of type 'string'.
```

#### üìò Uso de tipos inferidos y expl√≠citos en funciones

Como hemos visto, TypeScript infiere tipos autom√°ticamente, cuando las variables se declaran con un valor inicial. Esto solo se aplica a los par√°metros de las funciones cuando tienen un valor por defecto.

```tsx sample0.button.tsx
const handleClick = (event = new MouseEvent('click')) => {
  console.log(event);
};
```

En caso de no tener un valor por defecto, TypeScript no puede inferir el tipo del par√°metro `event`, ya que podr√≠a ser cualquier cosa. Por lo tanto, el tipo de `event` es `any`.

```tsx sample0.button.tsx
const handleClick = (event) => {
  console.log(event);
};
```

Para evitar esto, es imprescindible usar una **anotaci√≥n de tipo** expl√≠cita para el par√°metro `event`, como `Event`.

```tsx sample0.button.tsx
const handleClick = (event: Event) => {
  console.log(event);
};
```


##### ‚öôÔ∏è Tipado del retorno de las funciones obligatorio

En el caso de las funciones es posible usar anotaciones de tipo expl√≠citas, tanto en sus par√°metros como en su valor de retorno.
El tipado del retorno de las funciones, aunque es opcional, pero mejora **la legibilidad** del c√≥digo y puede ayudar a **detectar errores** pronto, en la propia funci√≥n, en lugar de al usarla. Se profundizar√° en ello m√°s adelante.

```tsx
// Inferido
const handleClick = () => {
  console.log('clicked');
};

// Expl√≠cito
const handleMultiply = (a: number, b: number): number => {
  return a * b;
};
```

El tipado del retorno de las funciones es una buena pr√°ctica, especialmente √∫til en funciones complejas, donde la inferencia puede no ser suficiente o clara. Para hacer **obligatorio el tipado del retorno de las funciones**, se pueden usar dos mecanismos:

- se puede usar la opci√≥n `noImplicitAny` en el archivo de configuraci√≥n `tsconfig.json`, que obliga a TypeScript a mostrar un error si no se especifica un tipo de retorno.

```json
{
  "compilerOptions": {
    "noImplicitAny": true
  }
}
```

- se puede a√±adir una regla en el archivo de configuraci√≥n de ESLint, que obligue a especificar el tipo de retorno de las funciones, o al menos que muestre una advertencia.

```json
{
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "error" // o "warn"
  }
}
```

### üß† Tipos propios (custom Types)

Existen dos mecanismos en TypeScript para dar nombre a nuevos tipos, denominados **tipos propios**, que pueden ser importados y exportados entre diferentes m√≥dulos:

- **Alias de tipos** (type aliases)
- **Interfaces** (interfaces)

#### Alias de tipos (type aliases)

Los alias de tipos permiten dar nombre a un tipo y reutilizarlo en diferentes partes del c√≥digo. Se definen con el operador `type` y se pueden utilizar para definir con un nombre cualquiera de los tipos que existen en TypeScript, como los tipos de objetos, tipos de tuplas, tipos de uni√≥n y tipos de intersecci√≥n que ya conocemos.

```ts sample0.types.1.ts
type User = { name: string; age: number };
type Tuple = readonly [string, number];
type Success = { status: 'success'; data: string[] };
type Fail = { status: 'error'; error: Error };
type Response = Success | Fail;
```

Igualmente se pueden usar alias de tipos para definir tipos de funciones, que se pueden reutilizar en diferentes partes del c√≥digo.

```ts sample0.types.1.ts
type Callback = (a: number, b: number) => number;
const add: Callback = (a, b) => a + b;
const multiply: Callback = (a, b) => a * b;
```

Al dar nombres a tipos, se pueden **simplificar definiciones** de tipos complejos, y **reutilizar** los nombres en diferentes partes del c√≥digo, incluyendo otros m√≥dulos.

A diferencia de lo que ocurre con las interfaces, tambi√©n se pueden usar alias de tipos para renombrar tipos **primitivos** y tipos **literales** o conjunto de cualquiera de ellos, creados mediante uniones o intersecciones.

```ts sample0.types.1.ts
type Name = string;
type Age = number;
type ID = string | number;
type Status = 'success' | 'error';
type Firsts = 1 | 2 | 3 | 4 | 5;
type Events = 2 | 4 | 6 | 8;
```

En estos casos destaca especialmente el valor sem√°ntico de los alias de tipos, que permiten **dar nombre** a los tipos y **mejorar la legibilidad** del c√≥digo.

#### Interfaces

Las interfaces son otra forma de dar un nombre a un tipo, pero no a cualquier tipo de TypeScript, no pudiendo usarse con tipos primitivos o sus literales. Se definen con la palabra clave `interface` y se pueden utilizar para definir tipos de objetos, tipos de funciones y tipos de clases.

```ts sample0.types.1.ts
export type User = {
  name: string;
  age: number;
};

export interface User {
  name: string;
  age: number;
}
```

Igual que en los objetos, en los tipos u en los interfaces se pueden incluir **propiedades opcionales** y **propiedades de solo lectura**.

```ts sample0.types.1.ts
export interface User {
  name: string;
  age: number;
  pet?: string;
  readonly id: string;
}
```

##### Interfaces y clases

Las clases en TypeScript son en si mismas una interfaz, por lo que pueden ser utilizadas para definir el tipo de cualquier variable.

```ts sample0.types.1.ts
export class User {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

const user: User = { name: 'Pepe', age: 30 };
```

M√°s adelante se ver√° el uso de las clases en TypeScript, pero por el momento es importante tener en cuenta que las interfaces y las clases son dos formas diferentes de definir tipos en TypeScript.

#### Tipos v. interfaces

En t√©rminos generales los tipos y los interfaces son intercambiables e incluso pueden utilizarse juntos a la hora de crear nuevos tipos. Sin embargo, existen algunas diferencias entre ellos:

- **Valores primitivos y literales**: los tipos pueden ser utilizados para definir cualquier tipo de TypeScript, incluyendo tipos primitivos y literales, mientras que las interfaces solo pueden ser utilizadas para definir tipos de objetos.

```ts sample0.types.1.ts
type Name = string;
type Age = number;
type ID = string | number;
type Status = 'success' | 'error';
```

- **Fusi√≥n de declaraciones (declaration merging)**: las interfaces pueden volver a ser declarados lo que significa que se pueden extender mediante esta t√©cnica para crear interfaces m√°s complejos. Por el contrario, los tipos no pueden extenderse volviendo a ser declarados.

```ts sample0.types.2.ts
interface User {
  name: string;
}

interface User {
  age: number;
}
// User: { name: string; age: number }
```

##### Extensi√≥n de interfaces y combinaci√≥n de tipos

En ambos casos existen mecanismos de **extensi√≥n**, equivalentes pero diferentes:

En los interfaces se pueden extender otras interfaces, utilizando la palabra clave `extends`, y se pueden combinar con otras interfaces utilizando el operador `|` (uni√≥n).

```ts sample0.types.2.ts
interface User {
  name: string;
}

interface Admin extends User {
  role: string;
}
```

En el caso de los tipos se pueden combinar con otros tipos utilizando el operador `&` (intersecci√≥n).

```ts sample0.types.2.ts
type User = {
  name: string;
};

type Admin = User & {
  role: string;
};
```

En cualquiera de los casos, se puede usar el operador `|` (uni√≥n) para combinar tipos o interfaces

```ts sample0.types.2.ts
type User = {
  name: string;
  boss: string;
};

interface Admin {
  name: string;
  team: string;
}

type UserOrAdmin = User | Admin;
```

##### Uso de tipos o interfaces

La documentaci√≥n oficial de [TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces) indica:

> El uso de interfaces con extends a menudo puede ser m√°s eficiente para el compilador que el uso de alias de tipo con intersecciones.
> En general, puede elegir seg√∫n sus preferencias personales, y TypeScript le indicar√° si necesita que algo sea el otro tipo de declaraci√≥n.
> Si desea una heur√≠stica, use interface hasta que necesite usar caracter√≠sticas de type.

En la configuraci√≥n por defecto del Linter de TypeScript, existe una regla que obliga a usar interfaces en lugar de tipos para definir tipos de objetos (Use an `interface` instead of a `type`): `eslint@typescript-eslint/consistent-type-definitions`.

Si preferimos usar tipos en lugar de interfaces, podemos desactivar esta regla en el archivo de configuraci√≥n de ESLint.

```json
{
  "rules": {
    "@typescript-eslint/consistent-type-definitions": "off"
  }
}
```

### Tipado de los datos

Utilizando tipos propios, interfaces o incluso clases, se pueden definir tipos de datos complejos, que pueden ser reutilizados en diferentes partes del c√≥digo.

De esta manera pueden definirse

- las entities (entities) de la aplicaci√≥n, como usuarios, productos, pedidos, etc.
- los tipos de datos que se utilizan para el funcionamiento de la aplicaci√≥n

```ts sample1.data.ts
type User = {
  id: string;
  name: string;
  email: string;
  age: number;
};
```

A partir de un tipo de datos, se pueden definir otros tipos de datos m√°s complejos, como por ejemplo un tipo de datos que represente una lista de usuarios.

```ts sample1.data.ts
type UserList = {
  users: User[];
};
```

#### DTO (Data Transfer Object) y utilidades de tipos

Igualmente es posible definir tipos derivados de los ya existentes. Por ejemplo, en el caso de las entidades, es posible definir un tipo de datos que represente su **DTO** (Data Transfer Object), es decir el conjunto de datos que se transfieren al backend para que este pueda crear la entidad completa.

```ts sample1.data.ts
type UserDTO = Omit<User, 'id'>;
```

En la creaci√≥n del DTO usamos una utilidad de TypeScript, `Omit`, que permite crear un nuevo tipo a partir de otro, omitiendo una o varias propiedades. En este caso, omitimos la propiedad `id` del tipo `User`, ya que no es necesaria para crear el DTO.

Otras utilidades de TypeScript son

- `Pick`, que permite crear un nuevo tipo a partir de otro, seleccionando una o varias propiedades,
- `Partial`, que permite crear un nuevo tipo a partir de otro, haciendo todas las propiedades opcionales.
- `Required`, que permite crear un nuevo tipo a partir de otro, haciendo todas las propiedades requeridas.
- `Record`, que permite crear un nuevo tipo a partir de otro, definiendo un conjunto de propiedades y su tipo.
- `ReturnType`, que permite crear un nuevo tipo a partir de otro, definiendo el tipo de retorno de una funci√≥n.

M√°s adelante se ver√°n ejemplos de su uso.

### üß† Clases en ES6 y typeScript

#### Definici√≥n de clases en ES6+

La definici√≥n de clases con Class se incorpora en ES6(2015)

Se incluye la posibilidad de declarar

- **propiedades** de instancia
- m√©todo **constructor**
- **m√©todos** de instancia

Las propiedades se declaran al inicio de la implementaci√≥n de la clase.

Se pueden incluir en la clase miembros **est√°ticos**, que pertenecen a la clase en s√≠ y no a las instancias de la clase. Pueden ser m√©todos o propiedades (ES2022).
Adem√°s de propiedades y m√©todos est√°ticos, aparece la posibilidad de declarar un **bloque est√°tico**, `static {}` (ES2022), que se ejecuta una vez al declarar la clase.
En el contexto est√°tico, this pasa a ser la clase y no la instancia

En versiones recientes del est√°ndar de ES (ES2022) se incorpora la posibilidad de declarar **miembros privados** en las clases, mediante el uso del prefijo `#`, tanto en el caso de propiedades como de m√©todos, tanto de instancia como est√°ticos.
Cobra sentido definir sus accessors: getter y setter

```JS
class Person {
  static #nextId = 0;
  static #getNextId() {
      return this.#nextId++;
  }
  static {
      console.log('Initializing Person class');
      this.#nextId = 1;
  }

  #id = Person.#getNextId();
  name: string;
  #age: number;
  constructor(name: string, age: number) {
      this.name = name;
      this.#age = age;
  }

  get id() {
      return this.#id;
  }

  get age() {
      return this.#age;
  }

  set age(value) {
      this.#age = value;
  }

  greet() {
      return `Hola, soy ${this.name} y tengo ${this.age} a√±os`;
  }
}
```

#### Clases en TypeScript

Todos estos elementos de ES se incorporan en la implementaci√≥n de TypeScript, con la √∫nica modificaci√≥n de incorporar los tipos de las propiedades y de los par√°metros que les dar√°n valor.

```typescript
class Person {
  //...

  #id = Person.getNextId();
  name: string;
  #age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.#age = age;
  }

  //...
}
```

Opcionalmente, en los m√©todos, incluyendo los getters, se pueden a√±adir los tipos de retorno y de los par√°metros, para mejorar la legibilidad del c√≥digo y detectar errores de tipo en tiempo de compilaci√≥n.

```typescript
class Person {
  //...

  get id(): number {
    return this.#id;
  }

  get age(): number {
    return this.#age;
  }

  set age(value: number) {
    this.#age = value;
  }

  greet(): string {
    return `Hola, soy ${this.name} y tengo ${this.age} a√±os`;
  }
}
```

##### Modificadores de acceso

Existen tres modificadores de acceso en TypeScript, que controlan la **visibilidad** y **accesibilidad** de las propiedades y m√©todos de una clase.:

- **public**: es el modificador por defecto, y permite acceder a las propiedades y m√©todos desde cualquier parte del c√≥digo.
- **private**: solo permite acceder a las propiedades y m√©todos desde dentro de la clase en la que se han declarado.
- **protected**: permite acceder a las propiedades y m√©todos desde dentro de la clase en la que se han declarado y desde las clases que heredan de ella.

A la hora de declarar propiedades y m√©todos privados en las clases, el uso del modificador `private` puede sustituir al #, recientemente incorporado en ES.

```typescript
class Person {
  private static _nextId = 0;
  private static getNextId() {
    return this._nextId++;
  }
  static {
    console.log("Initializing Person class");
    this._nextId = 1;
  }

  private _id = Person.getNextId();
  name: string;
  private _age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this._age = age;
  }
  //...
}
```

Por convenio, las propiedades privadas se nombran con un gui√≥n bajo al principio, para diferenciarlas de las propiedades p√∫blicas.

Esto facilita poder definir los accessors (getter y setter) para las propiedades privadas, que permiten acceder a ellas desde fuera de la clase.

```typescript
class Person {
  //...

  get id() {
    return this._id;
  }

  get age() {
    return this._age;
  }

  set age(value: number) {
    this._age = value;
  }
  //...
}
```

La existencia de estos accessors permite decidir cuando una propiedades privada es de solo **lectura** (tiene getter), solo de **escritura** (tiene setter) o de **lectura y escritura** (tiene getter y setter).

Hay que tener en cuenta que la definici√≥n de una propiedad como `private` carece de **ning√∫n efecto** en el c√≥digo **JavaScript** resultante, ya que no existe en JS, por lo que despu√©s de la compilaci√≥n la propiedad ser√≠a publica. Con el modificador ## se consigue que la propiedad sea privada en JS, por lo que algunos autores recomiendan su uso en lugar de `private`

En cualquier caso hay que tener en cuenta que privado significa accesible solo desde **dentro de la instancia**: cualquier objeto de una clase puede acceder desde sus m√©todos a las propiedades privadas de otro objeto de la clase, e.g. si lo recibe como par√°metro.

Otro modificador de acceso que se puede usar en TypeScript es `readonly`, que permite declarar propiedades de solo lectura, que solo pueden ser asignadas en el constructor de la clase.

```typescript
class Person {
  private static _nextId = 0;
  private static getNextId() {
    return this._nextId++;
  }
  static {
    console.log("Initializing Person class");
    this._nextId = 1;
  }

  private readonly _id = Person.getNextId();
  name: string;
  private _age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this._age = age;
  }
  //...
}
```

##### Propiedades de par√°metros

En TypeScript se pueden declarar propiedades de par√°metros en el constructor de una clase, que son propiedades de instancia que se inicializan con los valores de los par√°metros que se pasan al constructor.

```typescript
class Person {
  constructor(public name: string, private age: number) {}
}
```

Indicar en los par√°metros del constructor los modificadores de acceso y el modificador `readonly` es una forma de **simplificar** la definici√≥n de las **propiedades** de la clase, que se crean sin necesidad de haberlas declarado y se inicializan con los valores de los par√°metros.

Esta caracter√≠stica no se puede aplicar a las propiedades privadas que utilizan el modificador ## de ES, que deben ser declaradas expl√≠citamente en la clase.

Nota: esta caracter√≠stica no es soportada por la ejecuci√≥n directa de c√≥digo Typescript en las √∫ltimas versiones de NodeJS

#### Herencia de clases

La herencia de clases es una caracter√≠stica de la programaci√≥n orientada a objetos que permite **reutilizar** el c√≥digo de una clase en otra clase, que se convierte en una **subclase** de la primera, que es la **superclase**.

Este proceso es soportado por ES6+ en basa a las clases tat como quedaron definidas en el est√°ndar utilizando la palabra clave `extends`.

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  greet() {
    return `Hola, soy ${this.name} y tengo ${this.age} a√±os`;
  }
}

class Employee extends Person {
  constructor(name, age, salary) {
    super(name, age);
    this.salary = salary;
  }
  greet() {
    return `${super.greet()} y cobro ${this.salary}‚Ç¨`;
  }
}
```

##### Sobre-escritura (overriding) de m√©todos

Este mismo c√≥digo, a√±adiendo los tipos adecuados, es v√°lido en TypeScript.

```typescript
class Person {
  constructor(public name: string, public age: number) {}

  greet() {
    return `Hola, soy ${this.name} y tengo ${this.age} a√±os`;
  }
}

class Employee extends Person {
  constructor(name: string, age: number, public salary: number) {
    super(name, age);
  }

  override greet() {
    return `${super.greet()} y cobro ${this.salary}‚Ç¨`;
  }
}
```

Se puede a√±adir el modificador `override` a los m√©todos de la subclase que sobrescriben a los m√©todos de la superclase, para indicar que se est√° sobrescribiendo un m√©todo de la superclase.

Si en tsconfig.json se activa la opci√≥n `noImplicitOverride` se activa la comprobaci√≥n de que los m√©todos que se sobrescriben tengan necesariamente el modificador `override`.

##### Clases abstractas

Adem√°s, en TypeScript se pueden definir **m√©todos abstractos** en las superclases declaradas como abstracts, que deben ser implementados en las subclases. En esta misma clase abstracta se pueden definir tambi√©n m√©todos no abstractos, implementados en la superclase como en cualquier otro caso.

```typescript
abstract class Person {
  constructor(public name: string, public age: number) {}

  abstract greet(): string;
  eat() {
    return "Estoy comiendo";
  }
}

class Employee extends Person {
  constructor(name: string, age: number, public salary: number) {
    super(name, age);
  }

  greet() {
    return `Hola, soy ${this.name} y tengo ${this.age} a√±os y cobro ${this.salary}‚Ç¨`;
  }
}
```
